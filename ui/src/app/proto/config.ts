/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.23.4
 * source: config.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export enum IoTControlType {
    INBOARD_GPIO = 0,
    FIRMATA = 1
}
export class DCMotorConfig extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        int1?: number;
        int2?: number;
        power?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("int1" in data && data.int1 != undefined) {
                this.int1 = data.int1;
            }
            if ("int2" in data && data.int2 != undefined) {
                this.int2 = data.int2;
            }
            if ("power" in data && data.power != undefined) {
                this.power = data.power;
            }
        }
    }
    get int1() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set int1(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get int2() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set int2(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get power() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set power(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        int1?: number;
        int2?: number;
        power?: number;
    }): DCMotorConfig {
        const message = new DCMotorConfig({});
        if (data.int1 != null) {
            message.int1 = data.int1;
        }
        if (data.int2 != null) {
            message.int2 = data.int2;
        }
        if (data.power != null) {
            message.power = data.power;
        }
        return message;
    }
    toObject() {
        const data: {
            int1?: number;
            int2?: number;
            power?: number;
        } = {};
        if (this.int1 != null) {
            data.int1 = this.int1;
        }
        if (this.int2 != null) {
            data.int2 = this.int2;
        }
        if (this.power != null) {
            data.power = this.power;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.int1 != 0)
            writer.writeInt32(1, this.int1);
        if (this.int2 != 0)
            writer.writeInt32(2, this.int2);
        if (this.power != 0)
            writer.writeInt32(3, this.power);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DCMotorConfig {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DCMotorConfig();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.int1 = reader.readInt32();
                    break;
                case 2:
                    message.int2 = reader.readInt32();
                    break;
                case 3:
                    message.power = reader.readInt32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): DCMotorConfig {
        return DCMotorConfig.deserialize(bytes);
    }
}
export class MotorConfig extends pb_1.Message {
    #one_of_decls: number[][] = [[2]];
    constructor(data?: any[] | ({
        iot_control?: string;
    } & (({
        dc?: DCMotorConfig;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("iot_control" in data && data.iot_control != undefined) {
                this.iot_control = data.iot_control;
            }
            if ("dc" in data && data.dc != undefined) {
                this.dc = data.dc;
            }
        }
    }
    get iot_control() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set iot_control(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get dc() {
        return pb_1.Message.getWrapperField(this, DCMotorConfig, 2) as DCMotorConfig;
    }
    set dc(value: DCMotorConfig) {
        pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_dc() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get motor_type() {
        const cases: {
            [index: number]: "none" | "dc";
        } = {
            0: "none",
            2: "dc"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2])];
    }
    static fromObject(data: {
        iot_control?: string;
        dc?: ReturnType<typeof DCMotorConfig.prototype.toObject>;
    }): MotorConfig {
        const message = new MotorConfig({});
        if (data.iot_control != null) {
            message.iot_control = data.iot_control;
        }
        if (data.dc != null) {
            message.dc = DCMotorConfig.fromObject(data.dc);
        }
        return message;
    }
    toObject() {
        const data: {
            iot_control?: string;
            dc?: ReturnType<typeof DCMotorConfig.prototype.toObject>;
        } = {};
        if (this.iot_control != null) {
            data.iot_control = this.iot_control;
        }
        if (this.dc != null) {
            data.dc = this.dc.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.iot_control.length)
            writer.writeString(1, this.iot_control);
        if (this.has_dc)
            writer.writeMessage(2, this.dc, () => this.dc.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MotorConfig {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MotorConfig();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.iot_control = reader.readString();
                    break;
                case 2:
                    reader.readMessage(message.dc, () => message.dc = DCMotorConfig.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): MotorConfig {
        return MotorConfig.deserialize(bytes);
    }
}
export class CarConfig extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        steering?: MotorConfig;
        throtle?: MotorConfig;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("steering" in data && data.steering != undefined) {
                this.steering = data.steering;
            }
            if ("throtle" in data && data.throtle != undefined) {
                this.throtle = data.throtle;
            }
        }
    }
    get steering() {
        return pb_1.Message.getWrapperField(this, MotorConfig, 1) as MotorConfig;
    }
    set steering(value: MotorConfig) {
        pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_steering() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get throtle() {
        return pb_1.Message.getWrapperField(this, MotorConfig, 2) as MotorConfig;
    }
    set throtle(value: MotorConfig) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_throtle() {
        return pb_1.Message.getField(this, 2) != null;
    }
    static fromObject(data: {
        steering?: ReturnType<typeof MotorConfig.prototype.toObject>;
        throtle?: ReturnType<typeof MotorConfig.prototype.toObject>;
    }): CarConfig {
        const message = new CarConfig({});
        if (data.steering != null) {
            message.steering = MotorConfig.fromObject(data.steering);
        }
        if (data.throtle != null) {
            message.throtle = MotorConfig.fromObject(data.throtle);
        }
        return message;
    }
    toObject() {
        const data: {
            steering?: ReturnType<typeof MotorConfig.prototype.toObject>;
            throtle?: ReturnType<typeof MotorConfig.prototype.toObject>;
        } = {};
        if (this.steering != null) {
            data.steering = this.steering.toObject();
        }
        if (this.throtle != null) {
            data.throtle = this.throtle.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_steering)
            writer.writeMessage(1, this.steering, () => this.steering.serialize(writer));
        if (this.has_throtle)
            writer.writeMessage(2, this.throtle, () => this.throtle.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CarConfig {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CarConfig();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.steering, () => message.steering = MotorConfig.deserialize(reader));
                    break;
                case 2:
                    reader.readMessage(message.throtle, () => message.throtle = MotorConfig.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CarConfig {
        return CarConfig.deserialize(bytes);
    }
}
export class FirmataConfig extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        device_name?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("device_name" in data && data.device_name != undefined) {
                this.device_name = data.device_name;
            }
        }
    }
    get device_name() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set device_name(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        device_name?: string;
    }): FirmataConfig {
        const message = new FirmataConfig({});
        if (data.device_name != null) {
            message.device_name = data.device_name;
        }
        return message;
    }
    toObject() {
        const data: {
            device_name?: string;
        } = {};
        if (this.device_name != null) {
            data.device_name = this.device_name;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.device_name.length)
            writer.writeString(1, this.device_name);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FirmataConfig {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FirmataConfig();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.device_name = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): FirmataConfig {
        return FirmataConfig.deserialize(bytes);
    }
}
export class IoTControlConfig extends pb_1.Message {
    #one_of_decls: number[][] = [[2]];
    constructor(data?: any[] | ({
        type?: IoTControlType;
    } & (({
        firmata?: FirmataConfig;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("type" in data && data.type != undefined) {
                this.type = data.type;
            }
            if ("firmata" in data && data.firmata != undefined) {
                this.firmata = data.firmata;
            }
        }
    }
    get type() {
        return pb_1.Message.getFieldWithDefault(this, 1, IoTControlType.INBOARD_GPIO) as IoTControlType;
    }
    set type(value: IoTControlType) {
        pb_1.Message.setField(this, 1, value);
    }
    get firmata() {
        return pb_1.Message.getWrapperField(this, FirmataConfig, 2) as FirmataConfig;
    }
    set firmata(value: FirmataConfig) {
        pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_firmata() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get config() {
        const cases: {
            [index: number]: "none" | "firmata";
        } = {
            0: "none",
            2: "firmata"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2])];
    }
    static fromObject(data: {
        type?: IoTControlType;
        firmata?: ReturnType<typeof FirmataConfig.prototype.toObject>;
    }): IoTControlConfig {
        const message = new IoTControlConfig({});
        if (data.type != null) {
            message.type = data.type;
        }
        if (data.firmata != null) {
            message.firmata = FirmataConfig.fromObject(data.firmata);
        }
        return message;
    }
    toObject() {
        const data: {
            type?: IoTControlType;
            firmata?: ReturnType<typeof FirmataConfig.prototype.toObject>;
        } = {};
        if (this.type != null) {
            data.type = this.type;
        }
        if (this.firmata != null) {
            data.firmata = this.firmata.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.type != IoTControlType.INBOARD_GPIO)
            writer.writeEnum(1, this.type);
        if (this.has_firmata)
            writer.writeMessage(2, this.firmata, () => this.firmata.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IoTControlConfig {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IoTControlConfig();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.type = reader.readEnum();
                    break;
                case 2:
                    reader.readMessage(message.firmata, () => message.firmata = FirmataConfig.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): IoTControlConfig {
        return IoTControlConfig.deserialize(bytes);
    }
}
export class VideoStreamConfig extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        ssrc?: number;
        h264_codec?: number;
        width?: number;
        height?: number;
        gstreamer_source?: string;
        format?: string;
        bitrate?: number;
        keyintmax?: number;
        h264_enc_tune?: string;
        h264_profile?: string;
        mtu?: number;
        udp_port?: number;
        udp_host?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("ssrc" in data && data.ssrc != undefined) {
                this.ssrc = data.ssrc;
            }
            if ("h264_codec" in data && data.h264_codec != undefined) {
                this.h264_codec = data.h264_codec;
            }
            if ("width" in data && data.width != undefined) {
                this.width = data.width;
            }
            if ("height" in data && data.height != undefined) {
                this.height = data.height;
            }
            if ("gstreamer_source" in data && data.gstreamer_source != undefined) {
                this.gstreamer_source = data.gstreamer_source;
            }
            if ("format" in data && data.format != undefined) {
                this.format = data.format;
            }
            if ("bitrate" in data && data.bitrate != undefined) {
                this.bitrate = data.bitrate;
            }
            if ("keyintmax" in data && data.keyintmax != undefined) {
                this.keyintmax = data.keyintmax;
            }
            if ("h264_enc_tune" in data && data.h264_enc_tune != undefined) {
                this.h264_enc_tune = data.h264_enc_tune;
            }
            if ("h264_profile" in data && data.h264_profile != undefined) {
                this.h264_profile = data.h264_profile;
            }
            if ("mtu" in data && data.mtu != undefined) {
                this.mtu = data.mtu;
            }
            if ("udp_port" in data && data.udp_port != undefined) {
                this.udp_port = data.udp_port;
            }
            if ("udp_host" in data && data.udp_host != undefined) {
                this.udp_host = data.udp_host;
            }
        }
    }
    get ssrc() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set ssrc(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get h264_codec() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set h264_codec(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get width() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set width(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get height() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set height(value: number) {
        pb_1.Message.setField(this, 4, value);
    }
    get gstreamer_source() {
        return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
    }
    set gstreamer_source(value: string) {
        pb_1.Message.setField(this, 5, value);
    }
    get format() {
        return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
    }
    set format(value: string) {
        pb_1.Message.setField(this, 6, value);
    }
    get bitrate() {
        return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
    }
    set bitrate(value: number) {
        pb_1.Message.setField(this, 7, value);
    }
    get keyintmax() {
        return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
    }
    set keyintmax(value: number) {
        pb_1.Message.setField(this, 8, value);
    }
    get h264_enc_tune() {
        return pb_1.Message.getFieldWithDefault(this, 9, "") as string;
    }
    set h264_enc_tune(value: string) {
        pb_1.Message.setField(this, 9, value);
    }
    get h264_profile() {
        return pb_1.Message.getFieldWithDefault(this, 10, "") as string;
    }
    set h264_profile(value: string) {
        pb_1.Message.setField(this, 10, value);
    }
    get mtu() {
        return pb_1.Message.getFieldWithDefault(this, 11, 0) as number;
    }
    set mtu(value: number) {
        pb_1.Message.setField(this, 11, value);
    }
    get udp_port() {
        return pb_1.Message.getFieldWithDefault(this, 12, 0) as number;
    }
    set udp_port(value: number) {
        pb_1.Message.setField(this, 12, value);
    }
    get udp_host() {
        return pb_1.Message.getFieldWithDefault(this, 13, "") as string;
    }
    set udp_host(value: string) {
        pb_1.Message.setField(this, 13, value);
    }
    static fromObject(data: {
        ssrc?: number;
        h264_codec?: number;
        width?: number;
        height?: number;
        gstreamer_source?: string;
        format?: string;
        bitrate?: number;
        keyintmax?: number;
        h264_enc_tune?: string;
        h264_profile?: string;
        mtu?: number;
        udp_port?: number;
        udp_host?: string;
    }): VideoStreamConfig {
        const message = new VideoStreamConfig({});
        if (data.ssrc != null) {
            message.ssrc = data.ssrc;
        }
        if (data.h264_codec != null) {
            message.h264_codec = data.h264_codec;
        }
        if (data.width != null) {
            message.width = data.width;
        }
        if (data.height != null) {
            message.height = data.height;
        }
        if (data.gstreamer_source != null) {
            message.gstreamer_source = data.gstreamer_source;
        }
        if (data.format != null) {
            message.format = data.format;
        }
        if (data.bitrate != null) {
            message.bitrate = data.bitrate;
        }
        if (data.keyintmax != null) {
            message.keyintmax = data.keyintmax;
        }
        if (data.h264_enc_tune != null) {
            message.h264_enc_tune = data.h264_enc_tune;
        }
        if (data.h264_profile != null) {
            message.h264_profile = data.h264_profile;
        }
        if (data.mtu != null) {
            message.mtu = data.mtu;
        }
        if (data.udp_port != null) {
            message.udp_port = data.udp_port;
        }
        if (data.udp_host != null) {
            message.udp_host = data.udp_host;
        }
        return message;
    }
    toObject() {
        const data: {
            ssrc?: number;
            h264_codec?: number;
            width?: number;
            height?: number;
            gstreamer_source?: string;
            format?: string;
            bitrate?: number;
            keyintmax?: number;
            h264_enc_tune?: string;
            h264_profile?: string;
            mtu?: number;
            udp_port?: number;
            udp_host?: string;
        } = {};
        if (this.ssrc != null) {
            data.ssrc = this.ssrc;
        }
        if (this.h264_codec != null) {
            data.h264_codec = this.h264_codec;
        }
        if (this.width != null) {
            data.width = this.width;
        }
        if (this.height != null) {
            data.height = this.height;
        }
        if (this.gstreamer_source != null) {
            data.gstreamer_source = this.gstreamer_source;
        }
        if (this.format != null) {
            data.format = this.format;
        }
        if (this.bitrate != null) {
            data.bitrate = this.bitrate;
        }
        if (this.keyintmax != null) {
            data.keyintmax = this.keyintmax;
        }
        if (this.h264_enc_tune != null) {
            data.h264_enc_tune = this.h264_enc_tune;
        }
        if (this.h264_profile != null) {
            data.h264_profile = this.h264_profile;
        }
        if (this.mtu != null) {
            data.mtu = this.mtu;
        }
        if (this.udp_port != null) {
            data.udp_port = this.udp_port;
        }
        if (this.udp_host != null) {
            data.udp_host = this.udp_host;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.ssrc != 0)
            writer.writeInt32(1, this.ssrc);
        if (this.h264_codec != 0)
            writer.writeInt32(2, this.h264_codec);
        if (this.width != 0)
            writer.writeInt32(3, this.width);
        if (this.height != 0)
            writer.writeInt32(4, this.height);
        if (this.gstreamer_source.length)
            writer.writeString(5, this.gstreamer_source);
        if (this.format.length)
            writer.writeString(6, this.format);
        if (this.bitrate != 0)
            writer.writeInt32(7, this.bitrate);
        if (this.keyintmax != 0)
            writer.writeInt32(8, this.keyintmax);
        if (this.h264_enc_tune.length)
            writer.writeString(9, this.h264_enc_tune);
        if (this.h264_profile.length)
            writer.writeString(10, this.h264_profile);
        if (this.mtu != 0)
            writer.writeInt32(11, this.mtu);
        if (this.udp_port != 0)
            writer.writeInt32(12, this.udp_port);
        if (this.udp_host.length)
            writer.writeString(13, this.udp_host);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): VideoStreamConfig {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new VideoStreamConfig();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.ssrc = reader.readInt32();
                    break;
                case 2:
                    message.h264_codec = reader.readInt32();
                    break;
                case 3:
                    message.width = reader.readInt32();
                    break;
                case 4:
                    message.height = reader.readInt32();
                    break;
                case 5:
                    message.gstreamer_source = reader.readString();
                    break;
                case 6:
                    message.format = reader.readString();
                    break;
                case 7:
                    message.bitrate = reader.readInt32();
                    break;
                case 8:
                    message.keyintmax = reader.readInt32();
                    break;
                case 9:
                    message.h264_enc_tune = reader.readString();
                    break;
                case 10:
                    message.h264_profile = reader.readString();
                    break;
                case 11:
                    message.mtu = reader.readInt32();
                    break;
                case 12:
                    message.udp_port = reader.readInt32();
                    break;
                case 13:
                    message.udp_host = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): VideoStreamConfig {
        return VideoStreamConfig.deserialize(bytes);
    }
}
export class WebRTCConfig extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        ice_servers?: string[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("ice_servers" in data && data.ice_servers != undefined) {
                this.ice_servers = data.ice_servers;
            }
        }
    }
    get ice_servers() {
        return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
    }
    set ice_servers(value: string[]) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        ice_servers?: string[];
    }): WebRTCConfig {
        const message = new WebRTCConfig({});
        if (data.ice_servers != null) {
            message.ice_servers = data.ice_servers;
        }
        return message;
    }
    toObject() {
        const data: {
            ice_servers?: string[];
        } = {};
        if (this.ice_servers != null) {
            data.ice_servers = this.ice_servers;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.ice_servers.length)
            writer.writeRepeatedString(1, this.ice_servers);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WebRTCConfig {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WebRTCConfig();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): WebRTCConfig {
        return WebRTCConfig.deserialize(bytes);
    }
}
export class SignalingConfig extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        url?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("url" in data && data.url != undefined) {
                this.url = data.url;
            }
        }
    }
    get url() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set url(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        url?: string;
    }): SignalingConfig {
        const message = new SignalingConfig({});
        if (data.url != null) {
            message.url = data.url;
        }
        return message;
    }
    toObject() {
        const data: {
            url?: string;
        } = {};
        if (this.url != null) {
            data.url = this.url;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.url.length)
            writer.writeString(1, this.url);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignalingConfig {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignalingConfig();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.url = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): SignalingConfig {
        return SignalingConfig.deserialize(bytes);
    }
}
export class Config extends pb_1.Message {
    #one_of_decls: number[][] = [[10]];
    constructor(data?: any[] | ({
        id?: string;
        controls?: Map<string, IoTControlConfig>;
        web_rtc?: WebRTCConfig;
        video_stream?: VideoStreamConfig;
        signaling_config?: SignalingConfig;
    } & (({
        car?: CarConfig;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("id" in data && data.id != undefined) {
                this.id = data.id;
            }
            if ("controls" in data && data.controls != undefined) {
                this.controls = data.controls;
            }
            if ("web_rtc" in data && data.web_rtc != undefined) {
                this.web_rtc = data.web_rtc;
            }
            if ("video_stream" in data && data.video_stream != undefined) {
                this.video_stream = data.video_stream;
            }
            if ("signaling_config" in data && data.signaling_config != undefined) {
                this.signaling_config = data.signaling_config;
            }
            if ("car" in data && data.car != undefined) {
                this.car = data.car;
            }
        }
        if (!this.controls)
            this.controls = new Map();
    }
    get id() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set id(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get controls() {
        return pb_1.Message.getField(this, 2) as any as Map<string, IoTControlConfig>;
    }
    set controls(value: Map<string, IoTControlConfig>) {
        pb_1.Message.setField(this, 2, value as any);
    }
    get web_rtc() {
        return pb_1.Message.getWrapperField(this, WebRTCConfig, 3) as WebRTCConfig;
    }
    set web_rtc(value: WebRTCConfig) {
        pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_web_rtc() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get video_stream() {
        return pb_1.Message.getWrapperField(this, VideoStreamConfig, 4) as VideoStreamConfig;
    }
    set video_stream(value: VideoStreamConfig) {
        pb_1.Message.setWrapperField(this, 4, value);
    }
    get has_video_stream() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get signaling_config() {
        return pb_1.Message.getWrapperField(this, SignalingConfig, 5) as SignalingConfig;
    }
    set signaling_config(value: SignalingConfig) {
        pb_1.Message.setWrapperField(this, 5, value);
    }
    get has_signaling_config() {
        return pb_1.Message.getField(this, 5) != null;
    }
    get car() {
        return pb_1.Message.getWrapperField(this, CarConfig, 10) as CarConfig;
    }
    set car(value: CarConfig) {
        pb_1.Message.setOneofWrapperField(this, 10, this.#one_of_decls[0], value);
    }
    get has_car() {
        return pb_1.Message.getField(this, 10) != null;
    }
    get vehicule() {
        const cases: {
            [index: number]: "none" | "car";
        } = {
            0: "none",
            10: "car"
        };
        return cases[pb_1.Message.computeOneofCase(this, [10])];
    }
    static fromObject(data: {
        id?: string;
        controls?: {
            [key: string]: ReturnType<typeof IoTControlConfig.prototype.toObject>;
        };
        web_rtc?: ReturnType<typeof WebRTCConfig.prototype.toObject>;
        video_stream?: ReturnType<typeof VideoStreamConfig.prototype.toObject>;
        signaling_config?: ReturnType<typeof SignalingConfig.prototype.toObject>;
        car?: ReturnType<typeof CarConfig.prototype.toObject>;
    }): Config {
        const message = new Config({});
        if (data.id != null) {
            message.id = data.id;
        }
        if (typeof data.controls == "object") {
            message.controls = new Map(Object.entries(data.controls).map(([key, value]) => [key, IoTControlConfig.fromObject(value)]));
        }
        if (data.web_rtc != null) {
            message.web_rtc = WebRTCConfig.fromObject(data.web_rtc);
        }
        if (data.video_stream != null) {
            message.video_stream = VideoStreamConfig.fromObject(data.video_stream);
        }
        if (data.signaling_config != null) {
            message.signaling_config = SignalingConfig.fromObject(data.signaling_config);
        }
        if (data.car != null) {
            message.car = CarConfig.fromObject(data.car);
        }
        return message;
    }
    toObject() {
        const data: {
            id?: string;
            controls?: {
                [key: string]: ReturnType<typeof IoTControlConfig.prototype.toObject>;
            };
            web_rtc?: ReturnType<typeof WebRTCConfig.prototype.toObject>;
            video_stream?: ReturnType<typeof VideoStreamConfig.prototype.toObject>;
            signaling_config?: ReturnType<typeof SignalingConfig.prototype.toObject>;
            car?: ReturnType<typeof CarConfig.prototype.toObject>;
        } = {};
        if (this.id != null) {
            data.id = this.id;
        }
        if (this.controls != null) {
            data.controls = (Object.fromEntries)((Array.from)(this.controls).map(([key, value]) => [key, value.toObject()]));
        }
        if (this.web_rtc != null) {
            data.web_rtc = this.web_rtc.toObject();
        }
        if (this.video_stream != null) {
            data.video_stream = this.video_stream.toObject();
        }
        if (this.signaling_config != null) {
            data.signaling_config = this.signaling_config.toObject();
        }
        if (this.car != null) {
            data.car = this.car.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.id.length)
            writer.writeString(1, this.id);
        for (const [key, value] of this.controls) {
            writer.writeMessage(2, this.controls, () => {
                writer.writeString(1, key);
                writer.writeMessage(2, value, () => value.serialize(writer));
            });
        }
        if (this.has_web_rtc)
            writer.writeMessage(3, this.web_rtc, () => this.web_rtc.serialize(writer));
        if (this.has_video_stream)
            writer.writeMessage(4, this.video_stream, () => this.video_stream.serialize(writer));
        if (this.has_signaling_config)
            writer.writeMessage(5, this.signaling_config, () => this.signaling_config.serialize(writer));
        if (this.has_car)
            writer.writeMessage(10, this.car, () => this.car.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Config {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Config();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.id = reader.readString();
                    break;
                case 2:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.controls as any, reader, reader.readString, () => {
                        let value;
                        reader.readMessage(message, () => value = IoTControlConfig.deserialize(reader));
                        return value;
                    }));
                    break;
                case 3:
                    reader.readMessage(message.web_rtc, () => message.web_rtc = WebRTCConfig.deserialize(reader));
                    break;
                case 4:
                    reader.readMessage(message.video_stream, () => message.video_stream = VideoStreamConfig.deserialize(reader));
                    break;
                case 5:
                    reader.readMessage(message.signaling_config, () => message.signaling_config = SignalingConfig.deserialize(reader));
                    break;
                case 10:
                    reader.readMessage(message.car, () => message.car = CarConfig.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): Config {
        return Config.deserialize(bytes);
    }
}
